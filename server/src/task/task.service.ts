import {
  BadRequestException,
  // forwardRef,
  // HttpException,
  Inject,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common';

//mongoose
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { ObjectId } from 'mongodb';

//models + inputs + dtos
import { CreateTaskInput, UpdateTaskInput } from './task.inputs';
import { BaseTaskMongo, Task, TaskDocument } from './task.model';
import { BaseUserMongo } from 'src/user/user.model';
import { BaseBookMongo, Book } from 'src/book/book.model';
import { TaskStatus } from './task-status.enum';
import { TaskPriority } from './task-priority.enum';
import { TaskHistory } from './task-history.model';
import {
  UpdateTaskHistoryInput,
  CreateTaskHistoryInput,
} from './task-history.inputs';

//services
import { BookService } from 'src/book/book.service';

import { connectionFromArraySlice } from 'graphql-relay';
import ConnectionArgs from 'src/graphql/relay/connection.args';
import { TaskHistoryResponse, TaskRelay } from './task.response';
import {
  DEFAULT_TASK_HISTORY_PER_REQUEST,
  MAX_TASK_HISTORY_PER_REQUEST,
} from 'src/consts/defaults';

@Injectable()
export class TaskService {
  constructor(
    @InjectModel(Task.name) private readonly _taskModel: Model<TaskDocument>,
    private readonly _bookService: BookService,
  ) {}

  //TASKS
  async createTask(
    currentUser: BaseUserMongo,
    input: CreateTaskInput,
  ): Promise<Task> {
    try {
      const bookId = input.bookId ? input.bookId : '';
      const openLibraryBookId = input.openLibraryBookId
        ? input.openLibraryBookId.trim()
        : '';

      if (!bookId && !openLibraryBookId) {
        throw new BadRequestException(
          `Either field 'bookId' or 'openLibraryBookId' must be provided!`,
        );
      }

      let book: Book;
      if (bookId && openLibraryBookId) {
        book = await this._bookService.addExistingBook(currentUser, bookId);
      } else {
        if (bookId) {
          book = await this._bookService.addExistingBook(currentUser, bookId);
        } else if (openLibraryBookId) {
          book = await this._bookService.addBook(
            currentUser,
            openLibraryBookId,
          );
        }
      }

      //create a new task
      const newTask = {
        _id: new ObjectId(),
        title: input.title,
        description: input.description,
        status: TaskStatus.NEW,
        priority: input.priority ? input.priority : TaskPriority.NONE,
        history: [],
        owner: currentUser._id,
        attachItem: {
          _id: book._id,
          openLibraryId: book.openLibraryId,
          title: book.title,
          authors: book.authors,
          subjects: book.subjects,
          covers: book.covers,
        } as BaseBookMongo,
      } as BaseTaskMongo;

      const createdTask = new this._taskModel(newTask);

      //auto-generate
      const TASK_HISTORY_TITLE_FOR_NEW_TASK = `Task is created.`;
      const TASK_HISTORY_DESC_FOR_NEW_TASK = `This is an auto-generated task history.`;
      const newTaskHistory = {
        _id: new ObjectId(),
        taskId: newTask._id,
        title: TASK_HISTORY_TITLE_FOR_NEW_TASK,
        description: TASK_HISTORY_DESC_FOR_NEW_TASK,
        taskStatus: newTask.status,
        autoGenerated: true,
      };
      createdTask.history = [newTaskHistory];
      return await createdTask.save();
    } catch (e) {
      console.log(e);
      throw new InternalServerErrorException(e);
    }
  }

  //to-be-remove
  async getTask(currentUser: BaseUserMongo, taskId: ObjectId): Promise<Task> {
    const userId = currentUser._id;
    try {
      const found = await this._taskModel.findById(taskId);
      if (found) {
        if (found.owner.equals(userId)) {
          return found;
        } else {
          throw new UnauthorizedException("Cannot view other user's task.");
        }
      } else {
        throw new NotFoundException(`Task with ObjectId ${taskId} not found.`);
      }
    } catch (e) {
      console.log(e);
      throw new InternalServerErrorException();
    }
  }

  async getTaskRelay(
    currentUser: BaseUserMongo,
    taskId: ObjectId,
    args: ConnectionArgs,
  ): Promise<TaskRelay> {
    const userId = currentUser._id;
    let {
      limit: taskHistoryLimit,
      offset: taskHistoryOffset,
    } = args.pagingParams();
    
    if (!taskHistoryOffset) {
      taskHistoryOffset = 0;
    }
    if (!taskHistoryLimit) {
      taskHistoryLimit = DEFAULT_TASK_HISTORY_PER_REQUEST;
    }

    try {
      const found = await this._taskModel.findById(taskId);
      if (found) {
        if (found.owner.equals(userId)) {
          const taskHistory = found.history.slice(
            taskHistoryOffset,
            taskHistoryOffset + taskHistoryLimit,
          );
          const count = found.history.length;

          const page = connectionFromArraySlice(taskHistory, args, {
            arrayLength: count,
            sliceStart: taskHistoryOffset,
          });

          const taskHistoryRespose = {
            page,
            pageData: {
              count,
              limit: taskHistoryLimit,
              offset: taskHistoryOffset,
            },
          } as TaskHistoryResponse;

          //is there any better way to do this?
          const relay = {
            title: found.title,
            description: found.description,
            status: found.status,
            priority: found.priority,
            _id: found._id,
            owner: found.owner,
            attachItem: found.attachItem,
            history: taskHistoryRespose,
          } as TaskRelay;

          return relay;
        } else {
          throw new UnauthorizedException("Cannot view other user's task.");
        }
      } else {
        throw new NotFoundException(`Task with ObjectId ${taskId} not found.`);
      }
    } catch (e) {
      console.log(e);
      throw new InternalServerErrorException();
    }
  }

  async updateTask(
    currentUser: BaseUserMongo,
    input: UpdateTaskInput,
  ): Promise<Task> {
    const userId = currentUser._id;
    const taskId = input.taskId;
    try {
      const found = await this._taskModel.findById(taskId);
      if (found) {
        if (found.owner.equals(userId)) {
          const {
            title,
            description,
            status,
            priority,
            bookId,
            openLibraryBookId,
          } = input;

          if (title && found.title !== title) {
            found.title = title;
          }

          if (description && found.description !== description) {
            found.description = description;
          }

          if (status && found.status !== status) {
            found.status = status;
          }

          if (priority && found.priority !== priority) {
            found.priority = priority;
          }

          let book: Book;
          if (bookId && openLibraryBookId) {
            if (!found.attachItem._id.equals(bookId)) {
              book = await this._bookService.addExistingBook(
                currentUser,
                bookId,
              );
            }
          } else if (bookId || openLibraryBookId) {
            if (bookId) {
              if (!found.attachItem._id.equals(bookId)) {
                book = await this._bookService.addExistingBook(
                  currentUser,
                  bookId,
                );
              }
            } else if (openLibraryBookId) {
              if (found.attachItem.openLibraryId !== openLibraryBookId) {
                book = book = await this._bookService.addBook(
                  currentUser,
                  openLibraryBookId,
                );
              }
            }
          }
          if (book) {
            found.attachItem = book;
          }

          return await found.save();
        } else {
          throw new UnauthorizedException("Cannot edit other user's task.");
        }
      } else {
        throw new NotFoundException(`Task with ObjectId ${taskId} not found.`);
      }
    } catch (e) {
      console.log(e);
      throw new InternalServerErrorException(e);
    }
  }

  async deleteTask(
    currentUser: BaseUserMongo,
    taskId: ObjectId,
  ): Promise<ObjectId> {
    const userId = currentUser._id;
    try {
      const found = await this._taskModel.findById(taskId);

      if (found) {
        if (found.owner.equals(userId)) {
          await found.deleteOne();
          return taskId;
        } else {
          throw new UnauthorizedException("Cannot delete other user's task.");
        }
      } else {
        throw new NotFoundException(`Task with ObjectId ${taskId} not found.`);
      }
    } catch (e) {
      console.log(e);
      throw new InternalServerErrorException();
    }
  }

  //TASK-HISTORY
  async addTaskHistory(
    currentUser: BaseUserMongo,
    input: CreateTaskHistoryInput,
  ): Promise<TaskHistory> {
    const userId = currentUser._id;
    const taskId = input.taskId;
    try {
      const found = await this._taskModel.findById(taskId);
      if (found) {
        if (found.owner.equals(userId)) {
          const newTaskHistory = {
            _id: new ObjectId(),
            title: input.title,
            description: input.description,
            taskId,
            taskStatus: found.status,
            autoGenerated: false,
          };
          found.history = [newTaskHistory, ...found.history];
          await found.save();
          return newTaskHistory;
        } else {
          throw new UnauthorizedException("Cannot edit other user's task.");
        }
      } else {
        throw new NotFoundException(`Task with ObjectId ${taskId} not found.`);
      }
    } catch (e) {
      console.log(e);
      throw new InternalServerErrorException(e);
    }
  }

  // async getTaskHistory(currentUser: BaseUserMongo, taskId: ObjectId): Promise<Task> {
  //   const userId = currentUser._id;
  //   try {
  //     const found = await this._taskModel.findById(taskId);
  //     this._taskModel.findByIdAndUpdate(taskId, {}, {});

  //     if (found) {
  //       if (found.owner.equals(userId)) {
  //         return found;
  //       } else {
  //         throw new UnauthorizedException("Cannot view other user's task.");
  //       }
  //     } else {
  //       throw new NotFoundException(`Task with ObjectId ${taskId} not found.`);
  //     }
  //   } catch (e) {
  //     console.log(e);
  //     throw new InternalServerErrorException();
  //   }
  // }

  async updateTaskHistory(
    currentUser: BaseUserMongo,
    input: UpdateTaskHistoryInput,
  ): Promise<TaskHistory> {
    const userId = currentUser._id;
    const taskId = input.taskId;
    const taskHistoryId = input.taskHistoryId;
    try {
      const found = await this._taskModel.findById(taskId);
      if (found) {
        if (found.owner.equals(userId)) {
          const idx = found.history.findIndex((obj) =>
            obj._id.equals(taskHistoryId),
          );
          if (idx >= 0) {
            const toUpdate = found.history[idx];
            if (!toUpdate.autoGenerated) {
              const { title, description } = input;

              if (title) {
                toUpdate.title = title;
              }

              if (description) {
                toUpdate.description = description;
              }

              found.save();
              return found.history[idx];
            } else {
              throw new UnauthorizedException(
                'Cannot delete auto-generated task history.',
              );
            }
          } else {
            throw new NotFoundException(
              `TaskHistory with ObjectId ${taskHistoryId} not found.`,
            );
          }
        } else {
          throw new UnauthorizedException("Cannot edit other user's task.");
        }
      } else {
        throw new NotFoundException(`Task with ObjectId ${taskId} not found.`);
      }
    } catch (e) {
      console.log(e);
      throw new InternalServerErrorException(e);
    }
  }
}
